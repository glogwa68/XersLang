// XersLang Standard Library - File System Module
// Provides file I/O functions using builtins

// Read an entire file into a buffer
// path: file path string
// buf: pre-allocated buffer
// max_len: maximum bytes to read
// Returns number of bytes read, or -1 on error
fn file_read(path: i64, buf: i64, max_len: i64) -> i64 {
    return read_file(path, buf, max_len);
}

// Write data to a file
// path: file path string
// data: pointer to data to write
// len: number of bytes to write
// Returns number of bytes written, or -1 on error
fn file_write(path: i64, data: i64, len: i64) -> i64 {
    return write_file(path, data, len);
}

// Check if a file exists by attempting to read it
// path: file path string
// Returns 1 if file exists and is readable, 0 otherwise
fn file_exists(path: i64) -> i64 {
    // Allocate a small buffer for test read
    let test_buf = alloc(1);
    let result = read_file(path, test_buf, 1);

    // If read returned >= 0, file exists
    if result >= 0 {
        return 1;
    }
    return 0;
}

// Get the size of a file by reading it into a temporary buffer
// path: file path string
// Returns file size in bytes, or -1 on error
fn file_size(path: i64) -> i64 {
    // Allocate a large buffer to read the file
    let buf = alloc(65536);  // 64KB buffer
    let bytes_read = read_file(path, buf, 65536);
    return bytes_read;
}

// Read entire file and return a new buffer containing the data
// path: file path string
// size_out: pointer to i64 where size will be written
// Returns pointer to allocated buffer, or 0 on error
fn file_read_alloc(path: i64, size_out: i64) -> i64 {
    // First read to determine size
    let temp_buf = alloc(65536);  // 64KB temporary buffer
    let size = read_file(path, temp_buf, 65536);

    if size < 0 {
        // Error reading file
        mem_write_i64(size_out, 0, 0);
        return 0;
    }

    // Allocate exact size buffer
    let final_buf = alloc(size);

    // Read file again into final buffer
    let bytes_read = read_file(path, final_buf, size);

    // Store size
    mem_write_i64(size_out, 0, size);

    return final_buf;
}

// Append data to a file (note: this is a simplified implementation)
// In a real implementation, this would need a proper append mode
// For now, this is just a placeholder that uses write_file
fn file_append(path: i64, data: i64, len: i64) -> i64 {
    // Note: write_file in the current implementation likely overwrites
    // A proper implementation would need an append_file builtin
    return write_file(path, data, len);
}

// Copy a file from src to dst
// src: source file path
// dst: destination file path
// Returns number of bytes copied, or -1 on error
fn file_copy(src: i64, dst: i64) -> i64 {
    let buf = alloc(65536);  // 64KB buffer
    let bytes_read = read_file(src, buf, 65536);

    if bytes_read < 0 {
        return 0 - 1;  // -1
    }

    let bytes_written = write_file(dst, buf, bytes_read);
    return bytes_written;
}
