// XersLang Standard Library - String Module
// Provides string manipulation functions using builtins

// Get the length of a null-terminated string
// s: pointer to string
// Returns length (excluding null terminator)
fn str_len(s: i64) -> i64 {
    return strlen(s);
}

// Compare two strings for equality
// a: first string pointer
// b: second string pointer
// Returns 1 if equal, 0 if not equal
fn str_eq(a: i64, b: i64) -> i64 {
    let len_a = strlen(a);
    let len_b = strlen(b);

    // Different lengths means not equal
    if len_a != len_b {
        return 0;
    }

    // Compare character by character
    let i = 0;
    while i < len_a {
        let char_a = peek(a, i);
        let char_b = peek(b, i);
        if char_a != char_b {
            return 0;
        }
        i = i + 1;
    }

    return 1;  // equal
}

// Concatenate two strings into a new buffer
// a: first string
// b: second string
// dst: destination buffer (must be pre-allocated)
// Returns pointer to dst
fn str_concat(a: i64, b: i64, dst: i64) -> i64 {
    let len_a = strlen(a);
    let len_b = strlen(b);

    // Copy first string
    let i = 0;
    while i < len_a {
        let c = peek(a, i);
        poke(dst, i, c);
        i = i + 1;
    }

    // Copy second string
    let j = 0;
    while j < len_b {
        let c = peek(b, j);
        poke(dst, i + j, c);
        j = j + 1;
    }

    // Add null terminator
    poke(dst, i + j, 0);

    return dst;
}

// Allocate and concatenate two strings
// a: first string
// b: second string
// Returns pointer to newly allocated concatenated string
fn str_concat_alloc(a: i64, b: i64) -> i64 {
    let len_a = strlen(a);
    let len_b = strlen(b);
    let total_len = len_a + len_b + 1;  // +1 for null terminator

    let dst = alloc(total_len);
    return str_concat(a, b, dst);
}

// Copy a string to a destination buffer
// src: source string
// dst: destination buffer
// Returns pointer to dst
fn str_copy(src: i64, dst: i64) -> i64 {
    let len = strlen(src);
    let i = 0;
    while i < len {
        let c = peek(src, i);
        poke(dst, i, c);
        i = i + 1;
    }
    poke(dst, i, 0);  // null terminator
    return dst;
}

// Compare two strings lexicographically
// a: first string
// b: second string
// Returns -1 if a < b, 0 if a == b, 1 if a > b
fn str_cmp(a: i64, b: i64) -> i64 {
    let len_a = strlen(a);
    let len_b = strlen(b);
    let min_len = len_a;

    if len_b < min_len {
        min_len = len_b;
    }

    let i = 0;
    while i < min_len {
        let char_a = peek(a, i);
        let char_b = peek(b, i);
        if char_a < char_b {
            return 0 - 1;  // -1
        }
        if char_a > char_b {
            return 1;
        }
        i = i + 1;
    }

    // All characters matched, compare lengths
    if len_a < len_b {
        return 0 - 1;  // -1
    }
    if len_a > len_b {
        return 1;
    }
    return 0;  // equal
}
