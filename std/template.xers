// XersLang Standard Library - Template Module
// Provides project template generation for 'xersc new' and 'xersc init'
//
// Builtins used:
// - write_file(path, data, len) -> bytes written
// - is_dir(path) -> 1 if directory, 0 otherwise
// - path_join(base, name) -> ptr to joined path
// - alloc(size) -> ptr to allocated memory
// - poke(ptr, offset, byte) -> void
// - peek(ptr, offset) -> byte
// - strlen(s) -> length
// - print_str(s) -> void (for debug/info)
//
// NOTE: create_dir builtin is required but not yet implemented.
// For now, directories must exist or be created externally.

// ============================================================================
// String Building Utilities
// ============================================================================

// Write a string to a buffer at offset, return new offset
fn buf_write_str(buf: i64, offset: i64, src: i64) -> i64 {
    let len = strlen(src);
    let i = 0;
    while i < len {
        let c = peek(src, i);
        poke(buf, offset + i, c);
        i = i + 1;
    }
    return offset + len;
}

// Write a single character to buffer
fn buf_write_char(buf: i64, offset: i64, c: i64) -> i64 {
    poke(buf, offset, c);
    return offset + 1;
}

// Write a newline character
fn buf_write_newline(buf: i64, offset: i64) -> i64 {
    poke(buf, offset, 10);
    return offset + 1;
}

// ============================================================================
// Name Validation
// ============================================================================

// Check if a character is valid for project name (a-z, A-Z, 0-9, _, -)
fn is_valid_name_char(c: i64) -> i64 {
    // a-z
    if c >= 97 {
        if c <= 122 {
            return 1;
        }
    }
    // A-Z
    if c >= 65 {
        if c <= 90 {
            return 1;
        }
    }
    // 0-9
    if c >= 48 {
        if c <= 57 {
            return 1;
        }
    }
    // underscore
    if c == 95 {
        return 1;
    }
    // hyphen
    if c == 45 {
        return 1;
    }
    return 0;
}

// Validate project name
// Returns 1 if valid, 0 if invalid
fn validate_project_name(name: i64) -> i64 {
    let len = strlen(name);

    // Name must not be empty
    if len == 0 {
        return 0;
    }

    // Name must not be too long (max 64 chars)
    if len > 64 {
        return 0;
    }

    // First character must be a letter
    let first = peek(name, 0);
    // a-z
    let is_lower = 0;
    if first >= 97 {
        if first <= 122 {
            is_lower = 1;
        }
    }
    // A-Z
    let is_upper = 0;
    if first >= 65 {
        if first <= 90 {
            is_upper = 1;
        }
    }
    if is_lower == 0 {
        if is_upper == 0 {
            return 0;
        }
    }

    // Check all characters
    let i = 0;
    while i < len {
        let c = peek(name, i);
        if is_valid_name_char(c) == 0 {
            return 0;
        }
        i = i + 1;
    }

    return 1;
}

// ============================================================================
// Template: xers.toml
// ============================================================================

// Generate xers.toml content
// buf: output buffer (must be pre-allocated, ~1KB recommended)
// name: project name
// is_lib: 1 for library, 0 for application
// Returns length of content
fn generate_toml_content(buf: i64, name: i64, is_lib: i64) -> i64 {
    let off = 0;

    // [package]
    off = buf_write_str(buf, off, "[package]");
    off = buf_write_newline(buf, off);

    // name = "{name}"
    off = buf_write_str(buf, off, "name = \"");
    off = buf_write_str(buf, off, name);
    off = buf_write_str(buf, off, "\"");
    off = buf_write_newline(buf, off);

    // version = "0.1.0"
    off = buf_write_str(buf, off, "version = \"0.1.0\"");
    off = buf_write_newline(buf, off);

    // authors = ["Author"]
    off = buf_write_str(buf, off, "authors = [\"Author\"]");
    off = buf_write_newline(buf, off);

    // edition = "2025"
    off = buf_write_str(buf, off, "edition = \"2025\"");
    off = buf_write_newline(buf, off);

    // Empty line
    off = buf_write_newline(buf, off);

    // [build]
    off = buf_write_str(buf, off, "[build]");
    off = buf_write_newline(buf, off);

    // output
    off = buf_write_str(buf, off, "output = \"build/");
    off = buf_write_str(buf, off, name);
    if is_lib == 1 {
        off = buf_write_str(buf, off, ".lib\"");
    } else {
        off = buf_write_str(buf, off, ".exe\"");
    }
    off = buf_write_newline(buf, off);

    // target = "x64-windows"
    off = buf_write_str(buf, off, "target = \"x64-windows\"");
    off = buf_write_newline(buf, off);

    // Empty line
    off = buf_write_newline(buf, off);

    // # [dependencies]
    off = buf_write_str(buf, off, "# [dependencies]");
    off = buf_write_newline(buf, off);

    // Null terminate
    poke(buf, off, 0);

    return off;
}

// ============================================================================
// Template: main.xers (Application)
// ============================================================================

// Generate main.xers content for application
// buf: output buffer
// name: project name
// Returns length of content
fn generate_main_content(buf: i64, name: i64) -> i64 {
    let off = 0;

    // Header comment
    off = buf_write_str(buf, off, "// ");
    off = buf_write_str(buf, off, name);
    off = buf_write_str(buf, off, " - A XersLang application");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // main function
    off = buf_write_str(buf, off, "fn main() -> i64 {");
    off = buf_write_newline(buf, off);

    // print_str call
    off = buf_write_str(buf, off, "    print_str(\"Hello from ");
    off = buf_write_str(buf, off, name);
    off = buf_write_str(buf, off, "!\\n\");");
    off = buf_write_newline(buf, off);

    // return 0
    off = buf_write_str(buf, off, "    return 0;");
    off = buf_write_newline(buf, off);

    // closing brace
    off = buf_write_str(buf, off, "}");
    off = buf_write_newline(buf, off);

    // Null terminate
    poke(buf, off, 0);

    return off;
}

// ============================================================================
// Template: lib.xers (Library)
// ============================================================================

// Generate lib.xers content for library
// buf: output buffer
// name: project name
// Returns length of content
fn generate_lib_content(buf: i64, name: i64) -> i64 {
    let off = 0;

    // Header comment
    off = buf_write_str(buf, off, "// ");
    off = buf_write_str(buf, off, name);
    off = buf_write_str(buf, off, " - A XersLang library");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Add function with doc comment
    off = buf_write_str(buf, off, "/// Add two numbers");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "pub fn add(a: i64, b: i64) -> i64 {");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    return a + b;");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "}");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Sub function with doc comment
    off = buf_write_str(buf, off, "/// Subtract two numbers");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "pub fn sub(a: i64, b: i64) -> i64 {");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    return a - b;");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "}");
    off = buf_write_newline(buf, off);

    // Null terminate
    poke(buf, off, 0);

    return off;
}

// ============================================================================
// Template: .gitignore
// ============================================================================

// Generate .gitignore content
// buf: output buffer
// Returns length of content
fn generate_gitignore_content(buf: i64) -> i64 {
    let off = 0;

    off = buf_write_str(buf, off, "/build/");
    off = buf_write_newline(buf, off);

    off = buf_write_str(buf, off, "*.exe");
    off = buf_write_newline(buf, off);

    off = buf_write_str(buf, off, "*.obj");
    off = buf_write_newline(buf, off);

    off = buf_write_str(buf, off, "*.pdb");
    off = buf_write_newline(buf, off);

    off = buf_write_str(buf, off, "*.lib");
    off = buf_write_newline(buf, off);

    // Null terminate
    poke(buf, off, 0);

    return off;
}

// ============================================================================
// Template: test_lib.xers (Library test file)
// ============================================================================

// Generate test_lib.xers content
// buf: output buffer
// name: project name
// Returns length of content
fn generate_test_lib_content(buf: i64, name: i64) -> i64 {
    let off = 0;

    // Header comment
    off = buf_write_str(buf, off, "// Tests for ");
    off = buf_write_str(buf, off, name);
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Import the library (conceptual, syntax may vary)
    off = buf_write_str(buf, off, "// use ");
    off = buf_write_str(buf, off, name);
    off = buf_write_str(buf, off, ";");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Test main function
    off = buf_write_str(buf, off, "fn main() -> i64 {");
    off = buf_write_newline(buf, off);

    // Test add
    off = buf_write_str(buf, off, "    // Test add function");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    let result = add(2, 3);");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    if result != 5 {");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "        print_str(\"FAIL: add(2, 3) != 5\\n\");");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "        return 1;");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    }");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Test sub
    off = buf_write_str(buf, off, "    // Test sub function");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    result = sub(10, 4);");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    if result != 6 {");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "        print_str(\"FAIL: sub(10, 4) != 6\\n\");");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "        return 1;");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    }");
    off = buf_write_newline(buf, off);
    off = buf_write_newline(buf, off);

    // Success message
    off = buf_write_str(buf, off, "    print_str(\"All tests passed!\\n\");");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "    return 0;");
    off = buf_write_newline(buf, off);
    off = buf_write_str(buf, off, "}");
    off = buf_write_newline(buf, off);

    // Null terminate
    poke(buf, off, 0);

    return off;
}

// ============================================================================
// Template: .gitkeep (empty placeholder)
// ============================================================================

// Generate .gitkeep content (empty file with optional comment)
fn generate_gitkeep_content(buf: i64) -> i64 {
    let off = 0;

    off = buf_write_str(buf, off, "# This file keeps the directory in git");
    off = buf_write_newline(buf, off);

    poke(buf, off, 0);
    return off;
}

// ============================================================================
// File Writing Utilities
// ============================================================================

// Write a template file
// path: full file path
// content: buffer containing content
// len: content length
// Returns 1 on success, 0 on failure
fn write_template_file(path: i64, content: i64, len: i64) -> i64 {
    let bytes_written = write_file(path, content, len);
    if bytes_written == len {
        return 1;
    }
    return 0;
}

// ============================================================================
// Project Structure Generation (Public API)
// ============================================================================

// Generate xers.toml for a project
// root: project root directory path
// name: project name
// is_lib: 1 for library, 0 for application
// Returns 1 on success, 0 on failure
fn generate_toml(root: i64, name: i64, is_lib: i64) -> i64 {
    // Allocate buffer for content (1KB should be enough)
    let buf = alloc(1024);

    // Generate content
    let len = generate_toml_content(buf, name, is_lib);

    // Build file path
    let path = path_join(root, "xers.toml");

    // Write file
    return write_template_file(path, buf, len);
}

// Generate main.xers for an application project
// root: project root directory path
// name: project name
// Returns 1 on success, 0 on failure
fn generate_main_xers(root: i64, name: i64) -> i64 {
    // Allocate buffer
    let buf = alloc(1024);

    // Generate content
    let len = generate_main_content(buf, name);

    // Build file path: root/src/main.xers
    let src_dir = path_join(root, "src");
    let path = path_join(src_dir, "main.xers");

    // Write file
    return write_template_file(path, buf, len);
}

// Generate lib.xers for a library project
// root: project root directory path
// name: project name
// Returns 1 on success, 0 on failure
fn generate_lib_xers(root: i64, name: i64) -> i64 {
    // Allocate buffer
    let buf = alloc(1024);

    // Generate content
    let len = generate_lib_content(buf, name);

    // Build file path: root/src/lib.xers
    let src_dir = path_join(root, "src");
    let path = path_join(src_dir, "lib.xers");

    // Write file
    return write_template_file(path, buf, len);
}

// Generate .gitignore for a project
// root: project root directory path
// Returns 1 on success, 0 on failure
fn generate_gitignore(root: i64) -> i64 {
    // Allocate buffer
    let buf = alloc(512);

    // Generate content
    let len = generate_gitignore_content(buf);

    // Build file path
    let path = path_join(root, ".gitignore");

    // Write file
    return write_template_file(path, buf, len);
}

// Generate test file for library
// root: project root directory path
// name: project name
// Returns 1 on success, 0 on failure
fn generate_test_lib(root: i64, name: i64) -> i64 {
    // Allocate buffer
    let buf = alloc(2048);

    // Generate content
    let len = generate_test_lib_content(buf, name);

    // Build file path: root/tests/test_lib.xers
    let tests_dir = path_join(root, "tests");
    let path = path_join(tests_dir, "test_lib.xers");

    // Write file
    return write_template_file(path, buf, len);
}

// Generate .gitkeep placeholder
// dir: directory path
// Returns 1 on success, 0 on failure
fn generate_gitkeep(dir: i64) -> i64 {
    // Allocate buffer
    let buf = alloc(128);

    // Generate content
    let len = generate_gitkeep_content(buf);

    // Build file path
    let path = path_join(dir, ".gitkeep");

    // Write file
    return write_template_file(path, buf, len);
}

// ============================================================================
// High-Level Project Creation Functions
// ============================================================================

// Create the project directory structure
// NOTE: This function assumes create_dir builtin exists.
// Currently returns success code but directories must be created externally.
// root: project root path
// is_lib: 1 for library, 0 for application
// Returns 1 on success, 0 on failure
fn create_project_structure(root: i64, is_lib: i64) -> i64 {
    // TODO: When create_dir builtin is available, create:
    // - root/
    // - root/src/
    // - root/tests/
    // - root/build/

    // For now, we return 1 assuming directories exist
    // The caller should create directories before calling this
    return 1;
}

// Create a new project (full workflow)
// name: project name (will also be used as directory name)
// is_lib: 1 for library, 0 for application
// Returns 1 on success, 0 on failure
fn create_new_project(name: i64, is_lib: i64) -> i64 {
    // Validate name
    if validate_project_name(name) == 0 {
        print_str("Error: Invalid project name\n");
        return 0;
    }

    // The project root is the name itself (current directory)
    let root = name;

    // Check if directory already exists
    if is_dir(root) == 1 {
        print_str("Error: Directory already exists: ");
        print_str(name);
        print_str("\n");
        return 0;
    }

    // Create directory structure
    // NOTE: Directories must be created externally for now
    if create_project_structure(root, is_lib) == 0 {
        print_str("Error: Failed to create project structure\n");
        return 0;
    }

    // Generate xers.toml
    if generate_toml(root, name, is_lib) == 0 {
        print_str("Error: Failed to create xers.toml\n");
        return 0;
    }

    // Generate source file
    if is_lib == 1 {
        // Library: create lib.xers
        if generate_lib_xers(root, name) == 0 {
            print_str("Error: Failed to create src/lib.xers\n");
            return 0;
        }

        // Create test file for library
        if generate_test_lib(root, name) == 0 {
            print_str("Error: Failed to create tests/test_lib.xers\n");
            return 0;
        }
    } else {
        // Application: create main.xers
        if generate_main_xers(root, name) == 0 {
            print_str("Error: Failed to create src/main.xers\n");
            return 0;
        }

        // Create .gitkeep in tests directory
        let tests_dir = path_join(root, "tests");
        if generate_gitkeep(tests_dir) == 0 {
            // Non-fatal, continue
        }
    }

    // Generate .gitignore
    if generate_gitignore(root) == 0 {
        print_str("Error: Failed to create .gitignore\n");
        return 0;
    }

    // Success message
    print_str("Created ");
    if is_lib == 1 {
        print_str("library");
    } else {
        print_str("application");
    }
    print_str(" project: ");
    print_str(name);
    print_str("\n");

    return 1;
}

// Initialize project in existing directory (xersc init)
// is_lib: 1 for library, 0 for application
// Returns 1 on success, 0 on failure
fn init_existing_project(is_lib: i64) -> i64 {
    // Use "." as root and extract name from current directory
    // For simplicity, we'll use a default name "project"
    let root = ".";
    let name = "project";

    // Check if xers.toml already exists
    let toml_path = path_join(root, "xers.toml");
    // We can't easily check file existence without read_file,
    // so we'll just try to create it

    // Generate xers.toml
    if generate_toml(root, name, is_lib) == 0 {
        print_str("Error: Failed to create xers.toml\n");
        return 0;
    }

    // Check if src directory exists, create source file if needed
    let src_dir = path_join(root, "src");

    if is_lib == 1 {
        // Library: create lib.xers if it doesn't exist
        if generate_lib_xers(root, name) == 0 {
            // Non-fatal, file might already exist
        }
    } else {
        // Application: create main.xers if it doesn't exist
        if generate_main_xers(root, name) == 0 {
            // Non-fatal, file might already exist
        }
    }

    // Generate .gitignore if it doesn't exist
    if generate_gitignore(root) == 0 {
        // Non-fatal
    }

    print_str("Initialized XersLang project in current directory\n");
    return 1;
}

// ============================================================================
// Utility: Check if file exists
// ============================================================================

// Check if a file exists by attempting to read it
// path: file path
// Returns 1 if exists, 0 otherwise
fn file_exists(path: i64) -> i64 {
    let buf = alloc(1);
    let result = read_file(path, buf, 1);
    if result >= 0 {
        return 1;
    }
    return 0;
}

// ============================================================================
// End of Template Module
// ============================================================================
