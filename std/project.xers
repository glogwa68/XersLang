// XersLang Standard Library - Project Detection Module
// Provides functions for detecting and managing XersLang projects.
// A project is identified by the presence of a xers.toml file.
//
// Dependencies: Uses builtins: peek, poke, strlen, streq, alloc, read_file, file_len
// Note: Some builtins mentioned in spec (is_file, is_dir, path_join) are not yet
// implemented, so we use read_file to check file existence.

// ============================================================================
// SECTION 1: CONSTANTS
// ============================================================================

// PROJECT_CONFIG structure offsets (48 bytes total)
fn PC_ROOT()    { return 0; }   // offset 0:  root_path (ptr)
fn PC_NAME()    { return 8; }   // offset 8:  name (ptr)
fn PC_VERSION() { return 16; }  // offset 16: version (ptr)
fn PC_OUTPUT()  { return 24; }  // offset 24: output_path (ptr)
fn PC_SRCDIR()  { return 32; }  // offset 32: source_dir (ptr)
fn PC_RELEASE() { return 40; }  // offset 40: is_release (i64)

// Maximum path length
fn MAX_PATH() { return 260; }

// ============================================================================
// SECTION 2: MEMORY UTILITIES (local copies)
// ============================================================================

fn proj_mem_write_i64(buf, off, val) {
    poke(buf, off, val);
    poke(buf, off + 1, val / 256);
    poke(buf, off + 2, val / 65536);
    poke(buf, off + 3, val / 16777216);
    poke(buf, off + 4, val / 4294967296);
    poke(buf, off + 5, val / 1099511627776);
    poke(buf, off + 6, val / 281474976710656);
    poke(buf, off + 7, val / 72057594037927936);
    return 0;
}

fn proj_mem_read_i64(buf, off) {
    let b0 = peek(buf, off);
    let b1 = peek(buf, off + 1);
    let b2 = peek(buf, off + 2);
    let b3 = peek(buf, off + 3);
    let b4 = peek(buf, off + 4);
    let b5 = peek(buf, off + 5);
    let b6 = peek(buf, off + 6);
    let b7 = peek(buf, off + 7);
    return b0 + b1*256 + b2*65536 + b3*16777216 + b4*4294967296 + b5*1099511627776 + b6*281474976710656 + b7*72057594037927936;
}

// ============================================================================
// SECTION 3: STRING UTILITIES
// ============================================================================

// Copy string from src to dst, returns length
fn proj_str_copy(src, dst) {
    let len = strlen(src);
    let i = 0;
    while i < len {
        let c = peek(src, i);
        poke(dst, i, c);
        i = i + 1;
    }
    poke(dst, i, 0);
    return len;
}

// Allocate and copy string
fn proj_str_dup(src) {
    let len = strlen(src);
    let dst = alloc(len + 1);
    proj_str_copy(src, dst);
    return dst;
}

// Check if string ends with suffix
fn str_ends_with(s, suffix) {
    let slen = strlen(s);
    let suflen = strlen(suffix);

    if suflen > slen {
        return 0;
    }

    let offset = slen - suflen;
    let i = 0;
    while i < suflen {
        let c1 = peek(s, offset + i);
        let c2 = peek(suffix, i);
        if c1 != c2 {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}

// ============================================================================
// SECTION 4: PATH MANIPULATION
// ============================================================================

// Check if character is path separator (Windows: \ or /)
fn is_path_sep(c) {
    if c == 92 { return 1; }   // backslash '\'
    if c == 47 { return 1; }   // forward slash '/'
    return 0;
}

// Find last path separator position, returns -1 if not found
fn find_last_sep(path) {
    let len = strlen(path);
    let i = len - 1;

    while i >= 0 {
        let c = peek(path, i);
        if is_path_sep(c) == 1 {
            return i;
        }
        i = i - 1;
    }
    return 0 - 1;  // -1
}

// Get parent directory (modifies path in place by truncating at last separator)
// Returns 1 if successful, 0 if already at root
fn get_parent_dir(path) {
    let sep_pos = find_last_sep(path);

    // No separator found - already at root or simple filename
    if sep_pos < 0 {
        return 0;
    }

    // Windows drive letter case: C:\ - don't go past the backslash
    if sep_pos == 2 {
        let c0 = peek(path, 0);
        let c1 = peek(path, 1);
        // Check if drive letter (A-Z or a-z) followed by ':'
        if c1 == 58 {  // ':'
            if c0 >= 65 {
                if c0 <= 90 {
                    // Already at root like C:\
                    return 0;
                }
            }
            if c0 >= 97 {
                if c0 <= 122 {
                    // Already at root like c:\
                    return 0;
                }
            }
        }
    }

    // For paths like C:\foo, keep C:\ (sep at position 2)
    if sep_pos == 2 {
        poke(path, 3, 0);  // Null terminate after C:\
        return 1;
    }

    // Truncate at separator
    poke(path, sep_pos, 0);
    return 1;
}

// Join two paths into dst buffer
// path_join(base, name, dst) -> dst
fn path_join(base, name, dst) {
    let base_len = strlen(base);
    let name_len = strlen(name);

    // Copy base
    let i = 0;
    while i < base_len {
        poke(dst, i, peek(base, i));
        i = i + 1;
    }

    // Add separator if base doesn't end with one
    if base_len > 0 {
        let last_char = peek(base, base_len - 1);
        if is_path_sep(last_char) == 0 {
            poke(dst, i, 92);  // Add backslash
            i = i + 1;
        }
    }

    // Copy name
    let j = 0;
    while j < name_len {
        poke(dst, i, peek(name, j));
        i = i + 1;
        j = j + 1;
    }

    // Null terminate
    poke(dst, i, 0);

    return dst;
}

// Allocate and join paths
fn path_join_alloc(base, name) {
    let base_len = strlen(base);
    let name_len = strlen(name);
    let dst = alloc(base_len + name_len + 2);  // +2 for separator and null
    return path_join(base, name, dst);
}

// ============================================================================
// SECTION 5: FILE EXISTENCE CHECK
// ============================================================================

// Check if a file exists by attempting to read it
// Uses read_file builtin - returns 1 if file exists, 0 otherwise
fn file_exists(path) {
    // Allocate small buffer for test read
    let test_buf = alloc(4);
    let result = read_file(path, test_buf, 1);

    // If read returned >= 0, file exists
    if result >= 0 {
        return 1;
    }
    return 0;
}

// ============================================================================
// SECTION 6: PROJECT ROOT DETECTION
// ============================================================================

// TOML filename constant: "xers.toml"
fn get_toml_name() {
    let name = alloc(16);
    // x=120, e=101, r=114, s=115, .=46, t=116, o=111, m=109, l=108
    poke(name, 0, 120);  // x
    poke(name, 1, 101);  // e
    poke(name, 2, 114);  // r
    poke(name, 3, 115);  // s
    poke(name, 4, 46);   // .
    poke(name, 5, 116);  // t
    poke(name, 6, 111);  // o
    poke(name, 7, 109);  // m
    poke(name, 8, 108);  // l
    poke(name, 9, 0);    // null terminator
    return name;
}

// Search for xers.toml by traversing up the directory tree
// start_path: Starting directory to search from
// Returns: Allocated string with project root path, or 0 if not found
fn find_project_root(start_path) {
    // Allocate working buffer
    let current = alloc(MAX_PATH());
    proj_str_copy(start_path, current);

    // Get the TOML filename
    let toml_name = get_toml_name();

    // Buffer for combined path
    let check_path = alloc(MAX_PATH());

    // Maximum iterations to prevent infinite loop
    let max_iters = 64;
    let iter = 0;

    while iter < max_iters {
        // Build path: current + "/" + "xers.toml"
        path_join(current, toml_name, check_path);

        // Check if xers.toml exists at this location
        if file_exists(check_path) == 1 {
            // Found it! Return a copy of current path
            return proj_str_dup(current);
        }

        // Try parent directory
        if get_parent_dir(current) == 0 {
            // Reached root, not found
            return 0;
        }

        iter = iter + 1;
    }

    // Safety exit - too many iterations
    return 0;
}

// ============================================================================
// SECTION 7: PROJECT MODE CHECK
// ============================================================================

// Check if running in project mode
// This uses the current working directory as starting point
// Returns: 1 if in project mode (xers.toml found), 0 otherwise
fn is_project_mode() {
    // Use "." as current directory
    let cwd = alloc(4);
    poke(cwd, 0, 46);   // '.'
    poke(cwd, 1, 0);

    let root = find_project_root(cwd);
    if root == 0 {
        return 0;
    }
    return 1;
}

// ============================================================================
// SECTION 8: TOML PARSING (SIMPLIFIED)
// ============================================================================

// Skip whitespace in buffer starting at position
fn skip_ws_in_buf(buf, pos, len) {
    while pos < len {
        let c = peek(buf, pos);
        if c != 32 {  // space
            if c != 9 {  // tab
                if c != 10 {  // newline
                    if c != 13 {  // carriage return
                        return pos;
                    }
                }
            }
        }
        pos = pos + 1;
    }
    return pos;
}

// Skip to end of line
fn skip_to_eol(buf, pos, len) {
    while pos < len {
        let c = peek(buf, pos);
        if c == 10 {  // newline
            return pos + 1;
        }
        if c == 13 {  // CR
            pos = pos + 1;
            if pos < len {
                if peek(buf, pos) == 10 {
                    return pos + 1;
                }
            }
            return pos;
        }
        pos = pos + 1;
    }
    return pos;
}

// Extract quoted string value starting after the opening quote
// Returns allocated string, pos updated to after closing quote
fn extract_quoted_string(buf, pos, len) {
    let start = pos;

    // Find closing quote
    while pos < len {
        let c = peek(buf, pos);
        if c == 34 {  // closing quote
            // Allocate and copy
            let slen = pos - start;
            let str = alloc(slen + 1);
            let i = 0;
            while i < slen {
                poke(str, i, peek(buf, start + i));
                i = i + 1;
            }
            poke(str, slen, 0);
            return str;
        }
        pos = pos + 1;
    }
    return 0;  // No closing quote found
}

// Check if buffer at position matches key string
fn match_key(buf, pos, key) {
    let klen = strlen(key);
    let i = 0;
    while i < klen {
        if peek(buf, pos + i) != peek(key, i) {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}

// Parse TOML value for a key, returns allocated string or 0
fn parse_toml_value(buf, len, key) {
    let klen = strlen(key);
    let pos = 0;

    while pos < len {
        pos = skip_ws_in_buf(buf, pos, len);
        if pos >= len {
            return 0;
        }

        let c = peek(buf, pos);

        // Skip comments
        if c == 35 {  // '#'
            pos = skip_to_eol(buf, pos, len);
            // Continue to next line
        } else {
            // Check if this line starts with our key
            if match_key(buf, pos, key) == 1 {
                pos = pos + klen;
                pos = skip_ws_in_buf(buf, pos, len);

                // Expect '='
                if pos < len {
                    if peek(buf, pos) == 61 {  // '='
                        pos = pos + 1;
                        pos = skip_ws_in_buf(buf, pos, len);

                        // Expect opening quote
                        if pos < len {
                            if peek(buf, pos) == 34 {  // '"'
                                pos = pos + 1;
                                return extract_quoted_string(buf, pos, len);
                            }
                        }
                    }
                }
            }
            // Skip to next line
            pos = skip_to_eol(buf, pos, len);
        }
    }

    return 0;  // Key not found
}

// ============================================================================
// SECTION 9: PROJECT CONFIGURATION LOADING
// ============================================================================

// Create key string "name"
fn key_name() {
    let k = alloc(8);
    poke(k, 0, 110);  // n
    poke(k, 1, 97);   // a
    poke(k, 2, 109);  // m
    poke(k, 3, 101);  // e
    poke(k, 4, 0);
    return k;
}

// Create key string "version"
fn key_version() {
    let k = alloc(12);
    poke(k, 0, 118);  // v
    poke(k, 1, 101);  // e
    poke(k, 2, 114);  // r
    poke(k, 3, 115);  // s
    poke(k, 4, 105);  // i
    poke(k, 5, 111);  // o
    poke(k, 6, 110);  // n
    poke(k, 7, 0);
    return k;
}

// Create key string "output"
fn key_output() {
    let k = alloc(12);
    poke(k, 0, 111);  // o
    poke(k, 1, 117);  // u
    poke(k, 2, 116);  // t
    poke(k, 3, 112);  // p
    poke(k, 4, 117);  // u
    poke(k, 5, 116);  // t
    poke(k, 6, 0);
    return k;
}

// Create key string "src"
fn key_src() {
    let k = alloc(8);
    poke(k, 0, 115);  // s
    poke(k, 1, 114);  // r
    poke(k, 2, 99);   // c
    poke(k, 3, 0);
    return k;
}

// Create default string "src/"
fn default_src_dir() {
    let d = alloc(8);
    poke(d, 0, 115);  // s
    poke(d, 1, 114);  // r
    poke(d, 2, 99);   // c
    poke(d, 3, 47);   // /
    poke(d, 4, 0);
    return d;
}

// Create default string "build/"
fn default_output() {
    let d = alloc(12);
    poke(d, 0, 98);   // b
    poke(d, 1, 117);  // u
    poke(d, 2, 105);  // i
    poke(d, 3, 108);  // l
    poke(d, 4, 100);  // d
    poke(d, 5, 47);   // /
    poke(d, 6, 0);
    return d;
}

// Create default string "unknown"
fn default_name() {
    let d = alloc(12);
    poke(d, 0, 117);  // u
    poke(d, 1, 110);  // n
    poke(d, 2, 107);  // k
    poke(d, 3, 110);  // n
    poke(d, 4, 111);  // o
    poke(d, 5, 119);  // w
    poke(d, 6, 110);  // n
    poke(d, 7, 0);
    return d;
}

// Create default string "0.0.0"
fn default_version() {
    let d = alloc(8);
    poke(d, 0, 48);   // 0
    poke(d, 1, 46);   // .
    poke(d, 2, 48);   // 0
    poke(d, 3, 46);   // .
    poke(d, 4, 48);   // 0
    poke(d, 5, 0);
    return d;
}

// Load project configuration from xers.toml
// root_path: Path to project root directory
// Returns: Pointer to PROJECT_CONFIG structure, or 0 on error
fn load_project_config(root_path) {
    // Allocate config structure
    let config = alloc(48);

    // Store root path
    let root_copy = proj_str_dup(root_path);
    proj_mem_write_i64(config, PC_ROOT(), root_copy);

    // Build path to xers.toml
    let toml_name = get_toml_name();
    let toml_path = path_join_alloc(root_path, toml_name);

    // Read TOML file
    let toml_len = file_len(toml_path);
    if toml_len <= 0 {
        // File doesn't exist or empty - use defaults
        proj_mem_write_i64(config, PC_NAME(), default_name());
        proj_mem_write_i64(config, PC_VERSION(), default_version());
        proj_mem_write_i64(config, PC_OUTPUT(), default_output());
        proj_mem_write_i64(config, PC_SRCDIR(), default_src_dir());
        proj_mem_write_i64(config, PC_RELEASE(), 0);
        return config;
    }

    let toml_buf = alloc(toml_len + 1);
    let bytes_read = read_file(toml_path, toml_buf, toml_len);
    if bytes_read <= 0 {
        // Read error - use defaults
        proj_mem_write_i64(config, PC_NAME(), default_name());
        proj_mem_write_i64(config, PC_VERSION(), default_version());
        proj_mem_write_i64(config, PC_OUTPUT(), default_output());
        proj_mem_write_i64(config, PC_SRCDIR(), default_src_dir());
        proj_mem_write_i64(config, PC_RELEASE(), 0);
        return config;
    }

    // Parse TOML fields
    let name = parse_toml_value(toml_buf, bytes_read, key_name());
    if name == 0 {
        name = default_name();
    }
    proj_mem_write_i64(config, PC_NAME(), name);

    let version = parse_toml_value(toml_buf, bytes_read, key_version());
    if version == 0 {
        version = default_version();
    }
    proj_mem_write_i64(config, PC_VERSION(), version);

    let output = parse_toml_value(toml_buf, bytes_read, key_output());
    if output == 0 {
        output = default_output();
    }
    proj_mem_write_i64(config, PC_OUTPUT(), output);

    let srcdir = parse_toml_value(toml_buf, bytes_read, key_src());
    if srcdir == 0 {
        srcdir = default_src_dir();
    }
    proj_mem_write_i64(config, PC_SRCDIR(), srcdir);

    // Default: not release mode
    proj_mem_write_i64(config, PC_RELEASE(), 0);

    return config;
}

// ============================================================================
// SECTION 10: CONFIG ACCESSORS
// ============================================================================

// Get project name from config
fn get_project_name(config) {
    return proj_mem_read_i64(config, PC_NAME());
}

// Get output path from config
fn get_output_path(config) {
    return proj_mem_read_i64(config, PC_OUTPUT());
}

// Get source directory from config
fn get_source_dir(config) {
    return proj_mem_read_i64(config, PC_SRCDIR());
}

// Get project root path from config
fn get_project_root_from_config(config) {
    return proj_mem_read_i64(config, PC_ROOT());
}

// Get version from config
fn get_project_version(config) {
    return proj_mem_read_i64(config, PC_VERSION());
}

// Check if release mode
fn is_release_mode(config) {
    return proj_mem_read_i64(config, PC_RELEASE());
}

// Set release mode
fn set_release_mode(config, is_release) {
    proj_mem_write_i64(config, PC_RELEASE(), is_release);
    return 0;
}

// ============================================================================
// SECTION 11: CONVENIENCE FUNCTIONS
// ============================================================================

// Get full path to source directory
// config: PROJECT_CONFIG pointer
// Returns: Allocated string with full path (root + src_dir)
fn get_full_source_path(config) {
    let root = get_project_root_from_config(config);
    let srcdir = get_source_dir(config);
    return path_join_alloc(root, srcdir);
}

// Get full path to output directory
// config: PROJECT_CONFIG pointer
// Returns: Allocated string with full path (root + output)
fn get_full_output_path(config) {
    let root = get_project_root_from_config(config);
    let output = get_output_path(config);
    return path_join_alloc(root, output);
}

// Get expected main entry point file path
// config: PROJECT_CONFIG pointer
// Returns: Allocated string with path to main.xers
fn get_main_file_path(config) {
    let src_path = get_full_source_path(config);
    let main_name = alloc(16);
    // m=109, a=97, i=105, n=110, .=46, x=120, e=101, r=114, s=115
    poke(main_name, 0, 109);  // m
    poke(main_name, 1, 97);   // a
    poke(main_name, 2, 105);  // i
    poke(main_name, 3, 110);  // n
    poke(main_name, 4, 46);   // .
    poke(main_name, 5, 120);  // x
    poke(main_name, 6, 101);  // e
    poke(main_name, 7, 114);  // r
    poke(main_name, 8, 115);  // s
    poke(main_name, 9, 0);
    return path_join_alloc(src_path, main_name);
}

// Get output executable path
// config: PROJECT_CONFIG pointer
// Returns: Allocated string with path to output .exe
fn get_output_exe_path(config) {
    let output_path = get_full_output_path(config);
    let name = get_project_name(config);

    // Create name.exe string
    let name_len = strlen(name);
    let exe_name = alloc(name_len + 8);  // .exe\0

    let i = 0;
    while i < name_len {
        poke(exe_name, i, peek(name, i));
        i = i + 1;
    }
    poke(exe_name, i, 46);   // .
    poke(exe_name, i + 1, 101);  // e
    poke(exe_name, i + 2, 120);  // x
    poke(exe_name, i + 3, 101);  // e
    poke(exe_name, i + 4, 0);

    return path_join_alloc(output_path, exe_name);
}
