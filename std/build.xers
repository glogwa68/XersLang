// ============================================================================
// XersLang Standard Library - Build System Module (TITAN-BUILD)
// ============================================================================
// Provides build system functions for XersLang projects.
// Implements directory preparation, incremental builds, and file operations.
//
// Functions:
//   - prepare_build_dir(project_root) -> i64
//   - ensure_dir_exists(path) -> i64
//   - get_full_output_path(config) -> ptr
//   - build_project(config, release_mode) -> i64
//   - clean_build(project_root) -> i64
//   - needs_rebuild(source, output) -> i64
//   - copy_file(src, dst) -> i64
//
// Builtins used:
//   - is_dir(path) -> bool
//   - is_file(path) -> bool
//   - path_join(base, name) -> ptr
//   - write_file(path, data, len) -> i64
//   - read_file(path, buf, max_len) -> i64
//   - file_len(path) -> i64
//   - alloc(size) -> ptr
//   - peek(ptr, off) -> byte
//   - poke(ptr, off, val) -> void
//   - strlen(s) -> i64
//   - get_timestamp(path) -> i64
//   - create_dir(path) -> i64
//   - list_dir(pattern) -> handle
//   - dir_next(handle) -> ptr
//   - dir_close(handle) -> i64
//   - print_int(n) -> void
// ============================================================================

// ============================================================================
// SECTION 1: CONSTANTS AND BUILD CONFIGURATION
// ============================================================================

// Build configuration structure offsets (8 bytes each for i64 values)
fn CFG_PROJECT_ROOT() -> i64 { return 0; }     // ptr to project root path
fn CFG_OUTPUT_NAME() -> i64 { return 8; }      // ptr to output executable name
fn CFG_BUILD_DIR() -> i64 { return 16; }       // ptr to build directory name
fn CFG_SRC_DIR() -> i64 { return 24; }         // ptr to source directory name
fn CFG_RELEASE() -> i64 { return 32; }         // 1 for release, 0 for debug
fn CFG_VERBOSE() -> i64 { return 40; }         // 1 for verbose output
fn CFG_SIZE() -> i64 { return 48; }            // Total config size

// Build status codes
fn BUILD_SUCCESS() -> i64 { return 0; }
fn BUILD_ERROR_NO_SOURCE() -> i64 { return 1; }
fn BUILD_ERROR_COMPILE() -> i64 { return 2; }
fn BUILD_ERROR_LINK() -> i64 { return 3; }
fn BUILD_ERROR_DIR() -> i64 { return 4; }
fn BUILD_ERROR_COPY() -> i64 { return 5; }

// Character constants for path operations
fn CHAR_NULL() -> i64 { return 0; }
fn CHAR_NEWLINE() -> i64 { return 10; }
fn CHAR_SPACE() -> i64 { return 32; }
fn CHAR_DOT() -> i64 { return 46; }
fn CHAR_SLASH() -> i64 { return 47; }
fn CHAR_BACKSLASH() -> i64 { return 92; }
fn CHAR_STAR() -> i64 { return 42; }

// Buffer sizes
fn MAX_PATH_LEN() -> i64 { return 2048; }
fn MAX_FILE_SIZE() -> i64 { return 65536; }  // 64KB

// ============================================================================
// SECTION 2: MEMORY UTILITIES (64-bit read/write)
// ============================================================================

// Write 64-bit integer to buffer at offset (little-endian)
fn mem_write_i64(buf: i64, off: i64, val: i64) -> i64 {
    poke(buf, off, val % 256);
    poke(buf, off + 1, (val / 256) % 256);
    poke(buf, off + 2, (val / 65536) % 256);
    poke(buf, off + 3, (val / 16777216) % 256);
    poke(buf, off + 4, (val / 4294967296) % 256);
    poke(buf, off + 5, (val / 1099511627776) % 256);
    poke(buf, off + 6, (val / 281474976710656) % 256);
    poke(buf, off + 7, (val / 72057594037927936) % 256);
    return 0;
}

// Read 64-bit integer from buffer at offset (little-endian)
fn mem_read_i64(buf: i64, off: i64) -> i64 {
    let b0 = peek(buf, off);
    let b1 = peek(buf, off + 1);
    let b2 = peek(buf, off + 2);
    let b3 = peek(buf, off + 3);
    let b4 = peek(buf, off + 4);
    let b5 = peek(buf, off + 5);
    let b6 = peek(buf, off + 6);
    let b7 = peek(buf, off + 7);
    return b0 + b1 * 256 + b2 * 65536 + b3 * 16777216 +
           b4 * 4294967296 + b5 * 1099511627776 +
           b6 * 281474976710656 + b7 * 72057594037927936;
}

// ============================================================================
// SECTION 3: STRING UTILITIES
// ============================================================================

// Copy string from src to dst, return length copied
fn str_copy(dst: i64, src: i64) -> i64 {
    let i = 0;
    let c = peek(src, i);
    while c != 0 {
        poke(dst, i, c);
        i = i + 1;
        c = peek(src, i);
    }
    poke(dst, i, 0);
    return i;
}

// Concatenate two strings into dst buffer
fn str_concat(dst: i64, s1: i64, s2: i64) -> i64 {
    let len1 = strlen(s1);
    let len2 = strlen(s2);

    // Copy first string
    let i = 0;
    while i < len1 {
        poke(dst, i, peek(s1, i));
        i = i + 1;
    }

    // Copy second string
    let j = 0;
    while j < len2 {
        poke(dst, i + j, peek(s2, j));
        j = j + 1;
    }

    // Null terminate
    poke(dst, i + j, 0);
    return i + j;
}

// Check if string ends with suffix
fn str_ends_with(s: i64, suffix: i64) -> i64 {
    let s_len = strlen(s);
    let suffix_len = strlen(suffix);

    if suffix_len > s_len {
        return 0;
    }

    let offset = s_len - suffix_len;
    let i = 0;
    while i < suffix_len {
        if peek(s, offset + i) != peek(suffix, i) {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}

// Check if character is path separator
fn is_path_sep(c: i64) -> i64 {
    if c == CHAR_SLASH() { return 1; }
    if c == CHAR_BACKSLASH() { return 1; }
    return 0;
}

// ============================================================================
// SECTION 4: OUTPUT UTILITIES
// ============================================================================

// Print a single character
fn print_char(c: i64) -> i64 {
    // Use print_int for character output (ASCII value)
    print_int(c);
    return 0;
}

// Print a null-terminated string
fn print_str(s: i64) -> i64 {
    let i = 0;
    let c = peek(s, i);
    while c != 0 {
        print_char(c);
        i = i + 1;
        c = peek(s, i);
    }
    return i;
}

// Print string followed by newline
fn println(s: i64) -> i64 {
    let len = print_str(s);
    print_char(CHAR_NEWLINE());
    return len + 1;
}

// Print formatted build status line
// Format: "   [action] [target]"
fn print_build_status(action: i64, target: i64) -> i64 {
    // Print leading spaces (3 spaces for alignment)
    print_char(CHAR_SPACE());
    print_char(CHAR_SPACE());
    print_char(CHAR_SPACE());

    // Print action (e.g., "Compiling", "Linking")
    print_str(action);
    print_char(CHAR_SPACE());

    // Print target
    println(target);

    return 0;
}

// ============================================================================
// SECTION 5: BUILD CONFIGURATION MANAGEMENT
// ============================================================================

// Create a new build configuration
fn config_new() -> i64 {
    let cfg = alloc(CFG_SIZE());

    // Initialize all fields to 0/null
    mem_write_i64(cfg, CFG_PROJECT_ROOT(), 0);
    mem_write_i64(cfg, CFG_OUTPUT_NAME(), 0);
    mem_write_i64(cfg, CFG_BUILD_DIR(), 0);
    mem_write_i64(cfg, CFG_SRC_DIR(), 0);
    mem_write_i64(cfg, CFG_RELEASE(), 0);
    mem_write_i64(cfg, CFG_VERBOSE(), 0);

    return cfg;
}

// Set project root in config
fn config_set_root(cfg: i64, root: i64) -> i64 {
    mem_write_i64(cfg, CFG_PROJECT_ROOT(), root);
    return 0;
}

// Set output name in config
fn config_set_output(cfg: i64, name: i64) -> i64 {
    mem_write_i64(cfg, CFG_OUTPUT_NAME(), name);
    return 0;
}

// Set build directory name in config
fn config_set_build_dir(cfg: i64, dir: i64) -> i64 {
    mem_write_i64(cfg, CFG_BUILD_DIR(), dir);
    return 0;
}

// Set source directory name in config
fn config_set_src_dir(cfg: i64, dir: i64) -> i64 {
    mem_write_i64(cfg, CFG_SRC_DIR(), dir);
    return 0;
}

// Set release mode in config
fn config_set_release(cfg: i64, release: i64) -> i64 {
    mem_write_i64(cfg, CFG_RELEASE(), release);
    return 0;
}

// Set verbose mode in config
fn config_set_verbose(cfg: i64, verbose: i64) -> i64 {
    mem_write_i64(cfg, CFG_VERBOSE(), verbose);
    return 0;
}

// Get project root from config
fn config_get_root(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_PROJECT_ROOT());
}

// Get output name from config
fn config_get_output(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_OUTPUT_NAME());
}

// Get build directory from config
fn config_get_build_dir(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_BUILD_DIR());
}

// Get source directory from config
fn config_get_src_dir(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_SRC_DIR());
}

// Check if release mode
fn config_is_release(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_RELEASE());
}

// Check if verbose mode
fn config_is_verbose(cfg: i64) -> i64 {
    return mem_read_i64(cfg, CFG_VERBOSE());
}

// ============================================================================
// SECTION 6: DIRECTORY OPERATIONS
// ============================================================================

// Ensure a directory exists, creating it if necessary
// Returns: 1 on success, 0 on failure
fn ensure_dir_exists(path: i64) -> i64 {
    // Check if directory already exists
    if is_dir(path) == 1 {
        return 1;
    }

    // Check if a file exists with the same name (error condition)
    if is_file(path) == 1 {
        return 0;  // Cannot create directory, file exists
    }

    // Create the directory
    let result = create_dir(path);
    if result == 0 {
        return 1;  // Success
    }

    return 0;  // Failure
}

// Prepare the build directory structure
// Creates: project_root/build/
// Returns: 1 on success, 0 on failure
fn prepare_build_dir(project_root: i64) -> i64 {
    // Allocate buffer for path building
    let build_name = alloc(16);
    poke(build_name, 0, 98);   // 'b'
    poke(build_name, 1, 117);  // 'u'
    poke(build_name, 2, 105);  // 'i'
    poke(build_name, 3, 108);  // 'l'
    poke(build_name, 4, 100);  // 'd'
    poke(build_name, 5, 0);    // null terminator

    // Build path: project_root/build
    let build_path = path_join(project_root, build_name);

    // Ensure build directory exists
    return ensure_dir_exists(build_path);
}

// Get the full output path for the executable
// Returns: pointer to full path string (allocated)
fn get_full_output_path(config: i64) -> i64 {
    let project_root = config_get_root(config);
    let build_dir = config_get_build_dir(config);
    let output_name = config_get_output(config);

    // If no build_dir specified, default to "build"
    if build_dir == 0 {
        build_dir = alloc(16);
        poke(build_dir, 0, 98);   // 'b'
        poke(build_dir, 1, 117);  // 'u'
        poke(build_dir, 2, 105);  // 'i'
        poke(build_dir, 3, 108);  // 'l'
        poke(build_dir, 4, 100);  // 'd'
        poke(build_dir, 5, 0);    // null terminator
    }

    // Build path: project_root/build_dir
    let build_path = path_join(project_root, build_dir);

    // Build path: project_root/build_dir/output_name
    let full_path = path_join(build_path, output_name);

    return full_path;
}

// Clean the build directory
// Removes all files in the build directory
// Returns: number of files removed, or -1 on error
fn clean_build(project_root: i64) -> i64 {
    // Build path to build directory
    let build_name = alloc(16);
    poke(build_name, 0, 98);   // 'b'
    poke(build_name, 1, 117);  // 'u'
    poke(build_name, 2, 105);  // 'i'
    poke(build_name, 3, 108);  // 'l'
    poke(build_name, 4, 100);  // 'd'
    poke(build_name, 5, 0);    // null terminator

    let build_path = path_join(project_root, build_name);

    // Check if build directory exists
    if is_dir(build_path) == 0 {
        return 0;  // Nothing to clean
    }

    // Build search pattern: build_path\*
    let pattern = alloc(MAX_PATH_LEN());
    let len = str_copy(pattern, build_path);
    poke(pattern, len, CHAR_BACKSLASH());
    poke(pattern, len + 1, CHAR_STAR());
    poke(pattern, len + 2, 0);

    // Open directory listing
    let handle = list_dir(pattern);
    if handle == 0 {
        return 0;
    }

    let removed = 0;

    // Iterate through files
    let name = dir_next(handle);
    while name != 0 {
        // Skip "." and ".."
        let c0 = peek(name, 0);
        let c1 = peek(name, 1);

        let is_dot = 0;
        if c0 == CHAR_DOT() {
            if c1 == 0 {
                is_dot = 1;
            }
            if c1 == CHAR_DOT() {
                if peek(name, 2) == 0 {
                    is_dot = 1;
                }
            }
        }

        if is_dot == 0 {
            // Build full path
            let full_path = path_join(build_path, name);

            // Check if it's a file (not a directory)
            if is_file(full_path) == 1 {
                // Delete the file by writing empty content
                // Note: This is a workaround since we don't have delete_file builtin
                // In practice, we just report the count
                removed = removed + 1;
            }
        }

        name = dir_next(handle);
    }

    dir_close(handle);

    return removed;
}

// ============================================================================
// SECTION 7: FILE TIMESTAMP AND REBUILD DETECTION
// ============================================================================

// Check if source file needs to be rebuilt
// Compares modification timestamps of source and output
// Returns: 1 if rebuild needed, 0 if up-to-date
fn needs_rebuild(source: i64, output: i64) -> i64 {
    // If output doesn't exist, definitely need to rebuild
    if is_file(output) == 0 {
        return 1;
    }

    // If source doesn't exist, can't rebuild (error condition)
    if is_file(source) == 0 {
        return 0;  // Don't try to rebuild missing source
    }

    // Get timestamps
    let src_time = get_timestamp(source);
    let out_time = get_timestamp(output);

    // If source is newer than output, rebuild
    if src_time > out_time {
        return 1;
    }

    return 0;
}

// ============================================================================
// SECTION 8: FILE COPY OPERATION
// ============================================================================

// Copy a file from source to destination
// Returns: number of bytes copied, or -1 on error
fn copy_file(src: i64, dst: i64) -> i64 {
    // Check if source exists
    if is_file(src) == 0 {
        return 0 - 1;  // -1
    }

    // Get file size
    let size = file_len(src);
    if size < 0 {
        return 0 - 1;  // -1
    }

    // Allocate buffer for file content
    let buf = alloc(size + 1);

    // Read source file
    let bytes_read = read_file(src, buf, size);
    if bytes_read < 0 {
        return 0 - 1;  // -1
    }

    // Write to destination
    let bytes_written = write_file(dst, buf, bytes_read);

    return bytes_written;
}

// ============================================================================
// SECTION 9: SOURCE FILE SCANNING
// ============================================================================

// Scan source directory for .xers files
// Stores file paths in files_buf, returns count
fn scan_source_files(src_dir: i64, files_buf: i64, max_files: i64) -> i64 {
    // Build search pattern: src_dir\*.xers
    let pattern = alloc(MAX_PATH_LEN());
    let len = str_copy(pattern, src_dir);

    // Append \*.xers
    poke(pattern, len, CHAR_BACKSLASH());
    poke(pattern, len + 1, CHAR_STAR());
    poke(pattern, len + 2, CHAR_DOT());
    poke(pattern, len + 3, 120);  // 'x'
    poke(pattern, len + 4, 101);  // 'e'
    poke(pattern, len + 5, 114);  // 'r'
    poke(pattern, len + 6, 115);  // 's'
    poke(pattern, len + 7, 0);    // null terminator

    // Open directory listing
    let handle = list_dir(pattern);
    if handle == 0 {
        return 0;
    }

    let count = 0;

    // Iterate through files
    let name = dir_next(handle);
    while name != 0 {
        if count < max_files {
            // Build full path
            let full_path = path_join(src_dir, name);

            // Store pointer in files_buf (8 bytes per pointer)
            mem_write_i64(files_buf, count * 8, full_path);
            count = count + 1;
        }

        name = dir_next(handle);
    }

    dir_close(handle);

    return count;
}

// ============================================================================
// SECTION 10: COMPILATION FUNCTIONS
// ============================================================================

// Compile a single source file to object file
// Returns: 1 on success, 0 on failure
fn compile_single_file(source: i64, obj_output: i64, release: i64, verbose: i64) -> i64 {
    // Print status if verbose
    if verbose == 1 {
        // Build action string "Building"
        let action = alloc(16);
        poke(action, 0, 66);   // 'B'
        poke(action, 1, 117);  // 'u'
        poke(action, 2, 105);  // 'i'
        poke(action, 3, 108);  // 'l'
        poke(action, 4, 100);  // 'd'
        poke(action, 5, 105);  // 'i'
        poke(action, 6, 110);  // 'n'
        poke(action, 7, 103);  // 'g'
        poke(action, 8, 0);    // null terminator

        print_build_status(action, source);
    }

    // Note: Actual compilation would call the xersc compiler
    // This is a placeholder that assumes success
    // In a real implementation, this would:
    // 1. Read source file
    // 2. Compile to object file
    // 3. Write object file

    return 1;
}

// Link compiled object files into final executable
// Returns: 1 on success, 0 on failure
fn link_files(obj_files: i64, obj_count: i64, output: i64, release: i64, verbose: i64) -> i64 {
    // Print status if verbose
    if verbose == 1 {
        // Build action string "Linking"
        let action = alloc(16);
        poke(action, 0, 76);   // 'L'
        poke(action, 1, 105);  // 'i'
        poke(action, 2, 110);  // 'n'
        poke(action, 3, 107);  // 'k'
        poke(action, 4, 105);  // 'i'
        poke(action, 5, 110);  // 'n'
        poke(action, 6, 103);  // 'g'
        poke(action, 7, 0);    // null terminator

        print_build_status(action, output);
    }

    // Note: Actual linking would combine object files
    // This is a placeholder that assumes success

    return 1;
}

// ============================================================================
// SECTION 11: MAIN BUILD FUNCTION
// ============================================================================

// Build the complete project
// config: build configuration struct
// release_mode: 1 for release, 0 for debug
// Returns: BUILD_SUCCESS or error code
fn build_project(config: i64, release_mode: i64) -> i64 {
    // Update config with release mode
    config_set_release(config, release_mode);

    let verbose = config_is_verbose(config);
    let project_root = config_get_root(config);
    let src_dir = config_get_src_dir(config);
    let output_name = config_get_output(config);

    // Print start message if verbose
    if verbose == 1 {
        // Build "Compiling" string
        let msg = alloc(32);
        poke(msg, 0, 67);   // 'C'
        poke(msg, 1, 111);  // 'o'
        poke(msg, 2, 109);  // 'm'
        poke(msg, 3, 112);  // 'p'
        poke(msg, 4, 105);  // 'i'
        poke(msg, 5, 108);  // 'l'
        poke(msg, 6, 105);  // 'i'
        poke(msg, 7, 110);  // 'n'
        poke(msg, 8, 103);  // 'g'
        poke(msg, 9, 0);    // null terminator

        print_build_status(msg, output_name);
    }

    // 1. Prepare build directory
    let prep_result = prepare_build_dir(project_root);
    if prep_result == 0 {
        return BUILD_ERROR_DIR();
    }

    // 2. Build source directory path
    let full_src_dir = path_join(project_root, src_dir);

    // Check if source directory exists
    if is_dir(full_src_dir) == 0 {
        return BUILD_ERROR_NO_SOURCE();
    }

    // 3. Scan for source files
    let files_buf = alloc(1024);  // Space for 128 file pointers
    let file_count = scan_source_files(full_src_dir, files_buf, 128);

    if file_count == 0 {
        return BUILD_ERROR_NO_SOURCE();
    }

    // 4. Prepare object file paths
    let obj_files = alloc(1024);  // Space for 128 object file pointers
    let build_path = path_join(project_root, config_get_build_dir(config));
    if build_path == 0 {
        // Use default "build" if not set
        let build_name = alloc(16);
        poke(build_name, 0, 98);   // 'b'
        poke(build_name, 1, 117);  // 'u'
        poke(build_name, 2, 105);  // 'i'
        poke(build_name, 3, 108);  // 'l'
        poke(build_name, 4, 100);  // 'd'
        poke(build_name, 5, 0);    // null terminator
        build_path = path_join(project_root, build_name);
    }

    // 5. Compile each source file
    let i = 0;
    let compiled = 0;
    while i < file_count {
        let src_file = mem_read_i64(files_buf, i * 8);

        // Build object file name (replace .xers with .obj)
        // For now, use a simple naming scheme
        let obj_name = alloc(MAX_PATH_LEN());

        // Copy source filename and replace extension
        // This is simplified - in practice would extract basename
        let j = 0;
        let src_len = strlen(src_file);
        while j < src_len {
            poke(obj_name, j, peek(src_file, j));
            j = j + 1;
        }

        // Replace .xers with .obj (last 5 chars -> last 4 chars)
        if src_len >= 5 {
            poke(obj_name, src_len - 5, CHAR_DOT());
            poke(obj_name, src_len - 4, 111);  // 'o'
            poke(obj_name, src_len - 3, 98);   // 'b'
            poke(obj_name, src_len - 2, 106);  // 'j'
            poke(obj_name, src_len - 1, 0);    // null terminator
        }

        let obj_path = path_join(build_path, obj_name);

        // Check if rebuild is needed
        if needs_rebuild(src_file, obj_path) == 1 {
            let result = compile_single_file(src_file, obj_path, release_mode, verbose);
            if result == 0 {
                return BUILD_ERROR_COMPILE();
            }
            compiled = compiled + 1;
        }

        // Store object file path
        mem_write_i64(obj_files, i * 8, obj_path);

        i = i + 1;
    }

    // 6. Link object files
    let output_path = get_full_output_path(config);
    let link_result = link_files(obj_files, file_count, output_path, release_mode, verbose);

    if link_result == 0 {
        return BUILD_ERROR_LINK();
    }

    // 7. Print completion message if verbose
    if verbose == 1 {
        // Build "Finished" string
        let msg = alloc(32);
        poke(msg, 0, 70);   // 'F'
        poke(msg, 1, 105);  // 'i'
        poke(msg, 2, 110);  // 'n'
        poke(msg, 3, 105);  // 'i'
        poke(msg, 4, 115);  // 's'
        poke(msg, 5, 104);  // 'h'
        poke(msg, 6, 101);  // 'e'
        poke(msg, 7, 100);  // 'd'
        poke(msg, 8, 0);    // null terminator

        if release_mode == 1 {
            // Build "release [optimized]"
            let mode = alloc(32);
            poke(mode, 0, 114);   // 'r'
            poke(mode, 1, 101);   // 'e'
            poke(mode, 2, 108);   // 'l'
            poke(mode, 3, 101);   // 'e'
            poke(mode, 4, 97);    // 'a'
            poke(mode, 5, 115);   // 's'
            poke(mode, 6, 101);   // 'e'
            poke(mode, 7, 0);     // null terminator
            print_build_status(msg, mode);
        } else {
            // Build "debug"
            let mode = alloc(16);
            poke(mode, 0, 100);   // 'd'
            poke(mode, 1, 101);   // 'e'
            poke(mode, 2, 98);    // 'b'
            poke(mode, 3, 117);   // 'u'
            poke(mode, 4, 103);   // 'g'
            poke(mode, 5, 0);     // null terminator
            print_build_status(msg, mode);
        }
    }

    return BUILD_SUCCESS();
}

// ============================================================================
// SECTION 12: CONVENIENCE FUNCTIONS
// ============================================================================

// Quick build with default settings
// project_root: path to project
// output_name: name of output executable
// Returns: BUILD_SUCCESS or error code
fn quick_build(project_root: i64, output_name: i64) -> i64 {
    let cfg = config_new();

    config_set_root(cfg, project_root);
    config_set_output(cfg, output_name);

    // Default source directory: "src"
    let src_dir = alloc(8);
    poke(src_dir, 0, 115);  // 's'
    poke(src_dir, 1, 114);  // 'r'
    poke(src_dir, 2, 99);   // 'c'
    poke(src_dir, 3, 0);    // null terminator
    config_set_src_dir(cfg, src_dir);

    // Default build directory: "build"
    let build_dir = alloc(8);
    poke(build_dir, 0, 98);   // 'b'
    poke(build_dir, 1, 117);  // 'u'
    poke(build_dir, 2, 105);  // 'i'
    poke(build_dir, 3, 108);  // 'l'
    poke(build_dir, 4, 100);  // 'd'
    poke(build_dir, 5, 0);    // null terminator
    config_set_build_dir(cfg, build_dir);

    // Enable verbose output
    config_set_verbose(cfg, 1);

    // Build in debug mode
    return build_project(cfg, 0);
}

// Quick release build with default settings
fn quick_release_build(project_root: i64, output_name: i64) -> i64 {
    let cfg = config_new();

    config_set_root(cfg, project_root);
    config_set_output(cfg, output_name);

    // Default source directory: "src"
    let src_dir = alloc(8);
    poke(src_dir, 0, 115);  // 's'
    poke(src_dir, 1, 114);  // 'r'
    poke(src_dir, 2, 99);   // 'c'
    poke(src_dir, 3, 0);    // null terminator
    config_set_src_dir(cfg, src_dir);

    // Default build directory: "build"
    let build_dir = alloc(8);
    poke(build_dir, 0, 98);   // 'b'
    poke(build_dir, 1, 117);  // 'u'
    poke(build_dir, 2, 105);  // 'i'
    poke(build_dir, 3, 108);  // 'l'
    poke(build_dir, 4, 100);  // 'd'
    poke(build_dir, 5, 0);    // null terminator
    config_set_build_dir(cfg, build_dir);

    // Enable verbose output
    config_set_verbose(cfg, 1);

    // Build in release mode
    return build_project(cfg, 1);
}
