// ============================================================================
// XersLang Standard Library - TOML Parser Module
// ============================================================================
// Provides minimal TOML parsing functionality for configuration files.
// Supports sections [section], key = "value" pairs, and # comments.
//
// Memory Layout for parsed TOML structure:
//   Offset 0: Number of sections (i64)
//   For each section:
//     +0: Section name pointer (i64)
//     +8: Number of key-value pairs (i64)
//     +16: Start of pairs array
//       Each pair: key_ptr (i64), value_ptr (i64) = 16 bytes
//
// Usage:
//   let toml = parse_toml(content);
//   let name = toml_get_string(toml, "package", "name");
// ============================================================================

// ============================================================================
// SECTION 1: CHARACTER CLASSIFICATION HELPERS
// ============================================================================

// Check if character is whitespace (space or tab, NOT newline)
fn toml_is_ws(c) {
    if c == 32 { return 1; }  // space
    if c == 9 { return 1; }   // tab
    return 0;
}

// Check if character is a newline (LF or CR)
fn toml_is_newline(c) {
    if c == 10 { return 1; }  // LF
    if c == 13 { return 1; }  // CR
    return 0;
}

// Check if character is alphanumeric or underscore or hyphen
fn toml_is_key_char(c) {
    // a-z
    if c >= 97 {
        if c <= 122 { return 1; }
    }
    // A-Z
    if c >= 65 {
        if c <= 90 { return 1; }
    }
    // 0-9
    if c >= 48 {
        if c <= 57 { return 1; }
    }
    // underscore
    if c == 95 { return 1; }
    // hyphen
    if c == 45 { return 1; }
    return 0;
}

// ============================================================================
// SECTION 2: MEMORY UTILITIES (inline for module independence)
// ============================================================================

fn toml_mem_write_i64(buf, off, val) {
    poke(buf, off, val);
    poke(buf, off + 1, val / 256);
    poke(buf, off + 2, val / 65536);
    poke(buf, off + 3, val / 16777216);
    poke(buf, off + 4, val / 4294967296);
    poke(buf, off + 5, val / 1099511627776);
    poke(buf, off + 6, val / 281474976710656);
    poke(buf, off + 7, val / 72057594037927936);
    return 0;
}

fn toml_mem_read_i64(buf, off) {
    let b0 = peek(buf, off);
    let b1 = peek(buf, off + 1);
    let b2 = peek(buf, off + 2);
    let b3 = peek(buf, off + 3);
    let b4 = peek(buf, off + 4);
    let b5 = peek(buf, off + 5);
    let b6 = peek(buf, off + 6);
    let b7 = peek(buf, off + 7);
    return b0 + b1*256 + b2*65536 + b3*16777216 + b4*4294967296 + b5*1099511627776 + b6*281474976710656 + b7*72057594037927936;
}

// ============================================================================
// SECTION 3: STRING UTILITIES
// ============================================================================

// Compare two null-terminated strings
fn toml_streq(a, b) {
    let i = 0;
    while 1 == 1 {
        let ca = peek(a, i);
        let cb = peek(b, i);
        if ca != cb { return 0; }
        if ca == 0 { return 1; }
        i = i + 1;
    }
    return 0;
}

// Copy n bytes from src to dst, add null terminator
fn toml_copy_n(dst, src, n) {
    let i = 0;
    while i < n {
        let c = peek(src, i);
        poke(dst, i, c);
        i = i + 1;
    }
    poke(dst, n, 0);  // null terminator
    return dst;
}

// ============================================================================
// SECTION 4: PARSING HELPERS
// ============================================================================

// Skip whitespace (not newlines)
// content: source string pointer
// pos: current position
// Returns: new position after whitespace
fn toml_skip_ws(content, pos) {
    while 1 == 1 {
        let c = peek(content, pos);
        if c == 0 { return pos; }
        if toml_is_ws(c) == 0 { return pos; }
        pos = pos + 1;
    }
    return pos;
}

// Skip to end of line (for comments)
// Returns: position of newline or end of string
fn toml_skip_line(content, pos) {
    while 1 == 1 {
        let c = peek(content, pos);
        if c == 0 { return pos; }
        if c == 10 { return pos; }
        if c == 13 { return pos; }
        pos = pos + 1;
    }
    return pos;
}

// Skip newline characters (LF, CR, CRLF)
fn toml_skip_newline(content, pos) {
    let c = peek(content, pos);
    if c == 13 {
        pos = pos + 1;
        c = peek(content, pos);
    }
    if c == 10 {
        pos = pos + 1;
    }
    return pos;
}

// Skip whitespace and empty lines
fn toml_skip_empty(content, pos) {
    while 1 == 1 {
        let c = peek(content, pos);
        if c == 0 { return pos; }
        if toml_is_ws(c) == 1 {
            pos = pos + 1;
        } else {
            if toml_is_newline(c) == 1 {
                pos = toml_skip_newline(content, pos);
            } else {
                return pos;
            }
        }
    }
    return pos;
}

// ============================================================================
// SECTION 5: SECTION PARSING
// ============================================================================

// Parse section header [section_name]
// Returns: pointer to allocated section name string, or 0 if not a section
// Sets pos_out to position after ]
fn toml_parse_section(content, pos, pos_out) {
    pos = toml_skip_ws(content, pos);

    let c = peek(content, pos);
    if c != 91 { return 0; }  // '[' = 91
    pos = pos + 1;

    let start = pos;
    while 1 == 1 {
        c = peek(content, pos);
        if c == 0 { return 0; }  // unexpected end
        if c == 93 {  // ']' = 93
            let len = pos - start;
            let name = alloc(len + 1);
            toml_copy_n(name, content + start, len);
            pos = pos + 1;  // skip ]
            toml_mem_write_i64(pos_out, 0, pos);
            return name;
        }
        if toml_is_key_char(c) == 0 {
            return 0;  // invalid character in section name
        }
        pos = pos + 1;
    }
    return 0;
}

// ============================================================================
// SECTION 6: KEY-VALUE PARSING
// ============================================================================

// Parse a key = "value" or key = 'value' line
// Returns 1 on success, 0 on failure/empty
// Outputs: key_out, value_out (pointers to allocated strings)
// pos_out: position after the line
fn toml_parse_kv(content, pos, key_out, value_out, pos_out) {
    pos = toml_skip_ws(content, pos);

    let c = peek(content, pos);

    // Check for comment
    if c == 35 {  // '#' = 35
        pos = toml_skip_line(content, pos);
        pos = toml_skip_newline(content, pos);
        toml_mem_write_i64(pos_out, 0, pos);
        return 0;  // no key-value, but continue parsing
    }

    // Check for empty line or section start
    if c == 0 { return 0; }
    if toml_is_newline(c) == 1 {
        pos = toml_skip_newline(content, pos);
        toml_mem_write_i64(pos_out, 0, pos);
        return 0;
    }
    if c == 91 { return 0; }  // '[' means new section

    // Parse key
    let key_start = pos;
    while 1 == 1 {
        c = peek(content, pos);
        if toml_is_key_char(c) == 0 {
            let key_len = pos - key_start;
            if key_len == 0 { return 0; }

            let key = alloc(key_len + 1);
            toml_copy_n(key, content + key_start, key_len);
            toml_mem_write_i64(key_out, 0, key);

            // Skip to =
            pos = toml_skip_ws(content, pos);
            c = peek(content, pos);
            if c != 61 {  // '=' = 61
                return 0;  // invalid format
            }
            pos = pos + 1;

            // Skip whitespace after =
            pos = toml_skip_ws(content, pos);
            c = peek(content, pos);

            // Parse value
            let quote_char = 0;
            if c == 34 {  // '"' = 34
                quote_char = 34;
                pos = pos + 1;
            } else {
                if c == 39 {  // "'" = 39
                    quote_char = 39;
                    pos = pos + 1;
                }
            }

            let val_start = pos;
            if quote_char != 0 {
                // Quoted string
                while 1 == 1 {
                    c = peek(content, pos);
                    if c == 0 { return 0; }
                    if c == quote_char {
                        let val_len = pos - val_start;
                        let val = alloc(val_len + 1);
                        toml_copy_n(val, content + val_start, val_len);
                        toml_mem_write_i64(value_out, 0, val);

                        pos = pos + 1;  // skip closing quote
                        pos = toml_skip_line(content, pos);
                        pos = toml_skip_newline(content, pos);
                        toml_mem_write_i64(pos_out, 0, pos);
                        return 1;
                    }
                    pos = pos + 1;
                }
            } else {
                // Unquoted value (number or bare key)
                while 1 == 1 {
                    c = peek(content, pos);
                    if c == 0 {
                        let val_len = pos - val_start;
                        let val = alloc(val_len + 1);
                        toml_copy_n(val, content + val_start, val_len);
                        toml_mem_write_i64(value_out, 0, val);
                        toml_mem_write_i64(pos_out, 0, pos);
                        return 1;
                    }
                    if toml_is_newline(c) == 1 {
                        let val_len = pos - val_start;
                        let val = alloc(val_len + 1);
                        toml_copy_n(val, content + val_start, val_len);
                        toml_mem_write_i64(value_out, 0, val);
                        pos = toml_skip_newline(content, pos);
                        toml_mem_write_i64(pos_out, 0, pos);
                        return 1;
                    }
                    if c == 35 {  // '#' comment
                        let val_len = pos - val_start;
                        // Trim trailing whitespace
                        while val_len > 0 {
                            let last = peek(content + val_start, val_len - 1);
                            if toml_is_ws(last) == 0 {
                                let val = alloc(val_len + 1);
                                toml_copy_n(val, content + val_start, val_len);
                                toml_mem_write_i64(value_out, 0, val);
                                pos = toml_skip_line(content, pos);
                                pos = toml_skip_newline(content, pos);
                                toml_mem_write_i64(pos_out, 0, pos);
                                return 1;
                            }
                            val_len = val_len - 1;
                        }
                        let val = alloc(1);
                        poke(val, 0, 0);
                        toml_mem_write_i64(value_out, 0, val);
                        pos = toml_skip_line(content, pos);
                        pos = toml_skip_newline(content, pos);
                        toml_mem_write_i64(pos_out, 0, pos);
                        return 1;
                    }
                    pos = pos + 1;
                }
            }
            return 0;
        }
        pos = pos + 1;
    }
    return 0;
}

// ============================================================================
// SECTION 7: MAIN PARSER
// ============================================================================

// Structure offsets for parsed TOML
// Header: section_count (i64) = 8 bytes
// Section entry: name_ptr (i64) + kv_count (i64) + pairs_ptr (i64) = 24 bytes
// KV pair: key_ptr (i64) + value_ptr (i64) = 16 bytes

fn TOML_HEADER_SIZE() { return 8; }
fn TOML_SECTION_SIZE() { return 24; }
fn TOML_KV_SIZE() { return 16; }
fn TOML_MAX_SECTIONS() { return 32; }
fn TOML_MAX_KV_PER_SECTION() { return 64; }

// Parse TOML content string
// content: pointer to null-terminated TOML string
// Returns: pointer to parsed TOML structure, or 0 on error
fn parse_toml(content) {
    // Allocate main structure
    // Header (8) + up to 32 sections * 24 bytes = 776 bytes
    let toml = alloc(TOML_HEADER_SIZE() + TOML_MAX_SECTIONS() * TOML_SECTION_SIZE());
    let section_count = 0;

    // Allocate temporary buffers for output parameters
    let pos_out = alloc(8);
    let key_out = alloc(8);
    let value_out = alloc(8);

    let pos = 0;
    let current_section = 0 - 1;  // -1 means no section yet
    let current_kv_count = 0;
    let current_kv_buf = 0;

    // Skip initial whitespace/comments
    pos = toml_skip_empty(content, pos);

    while 1 == 1 {
        let c = peek(content, pos);
        if c == 0 {
            // End of content - save last section if any
            if current_section >= 0 {
                let sec_off = TOML_HEADER_SIZE() + current_section * TOML_SECTION_SIZE();
                toml_mem_write_i64(toml, sec_off + 8, current_kv_count);
            }
            // Write section count
            toml_mem_write_i64(toml, 0, section_count);
            return toml;
        }

        // Check for comment
        if c == 35 {  // '#'
            pos = toml_skip_line(content, pos);
            pos = toml_skip_newline(content, pos);
            pos = toml_skip_empty(content, pos);
        } else {
            // Check for section
            if c == 91 {  // '['
                // Save previous section's kv_count
                if current_section >= 0 {
                    let sec_off = TOML_HEADER_SIZE() + current_section * TOML_SECTION_SIZE();
                    toml_mem_write_i64(toml, sec_off + 8, current_kv_count);
                }

                let section_name = toml_parse_section(content, pos, pos_out);
                if section_name == 0 {
                    // Parse error - skip line
                    pos = toml_skip_line(content, pos);
                    pos = toml_skip_newline(content, pos);
                } else {
                    pos = toml_mem_read_i64(pos_out, 0);

                    // Store new section
                    if section_count < TOML_MAX_SECTIONS() {
                        current_section = section_count;
                        let sec_off = TOML_HEADER_SIZE() + section_count * TOML_SECTION_SIZE();

                        // Allocate kv buffer for this section
                        current_kv_buf = alloc(TOML_MAX_KV_PER_SECTION() * TOML_KV_SIZE());
                        current_kv_count = 0;

                        toml_mem_write_i64(toml, sec_off, section_name);
                        toml_mem_write_i64(toml, sec_off + 8, 0);  // kv_count, updated later
                        toml_mem_write_i64(toml, sec_off + 16, current_kv_buf);

                        section_count = section_count + 1;
                    }
                    pos = toml_skip_empty(content, pos);
                }
            } else {
                // Try to parse key-value
                if current_section >= 0 {
                    let result = toml_parse_kv(content, pos, key_out, value_out, pos_out);
                    pos = toml_mem_read_i64(pos_out, 0);

                    if result == 1 {
                        // Got a key-value pair
                        if current_kv_count < TOML_MAX_KV_PER_SECTION() {
                            let kv_off = current_kv_count * TOML_KV_SIZE();
                            let key = toml_mem_read_i64(key_out, 0);
                            let val = toml_mem_read_i64(value_out, 0);

                            toml_mem_write_i64(current_kv_buf, kv_off, key);
                            toml_mem_write_i64(current_kv_buf, kv_off + 8, val);

                            current_kv_count = current_kv_count + 1;
                        }
                    }
                } else {
                    // No section yet - skip line
                    pos = toml_skip_line(content, pos);
                    pos = toml_skip_newline(content, pos);
                }
                pos = toml_skip_empty(content, pos);
            }
        }
    }

    return toml;
}

// ============================================================================
// SECTION 8: QUERY FUNCTIONS
// ============================================================================

// Get a section by name
// toml: parsed TOML structure
// section_name: section name to find
// Returns: pointer to section entry, or 0 if not found
fn toml_get_section(toml, section_name) {
    let section_count = toml_mem_read_i64(toml, 0);
    let i = 0;

    while i < section_count {
        let sec_off = TOML_HEADER_SIZE() + i * TOML_SECTION_SIZE();
        let name = toml_mem_read_i64(toml, sec_off);

        if toml_streq(name, section_name) == 1 {
            return toml + sec_off;
        }
        i = i + 1;
    }

    return 0;
}

// Get a value from a section
// section: pointer to section entry (from toml_get_section)
// key: key name to find
// Returns: pointer to value string, or 0 if not found
fn toml_get_value(section, key) {
    if section == 0 { return 0; }

    let kv_count = toml_mem_read_i64(section, 8);
    let kv_buf = toml_mem_read_i64(section, 16);

    let i = 0;
    while i < kv_count {
        let kv_off = i * TOML_KV_SIZE();
        let k = toml_mem_read_i64(kv_buf, kv_off);

        if toml_streq(k, key) == 1 {
            return toml_mem_read_i64(kv_buf, kv_off + 8);
        }
        i = i + 1;
    }

    return 0;
}

// Get a string value directly by section and key name
// toml: parsed TOML structure
// section_name: section name (e.g., "package")
// key: key name (e.g., "name")
// Returns: pointer to value string, or 0 if not found
fn toml_get_string(toml, section_name, key) {
    let section = toml_get_section(toml, section_name);
    if section == 0 { return 0; }
    return toml_get_value(section, key);
}

// ============================================================================
// SECTION 9: FILE LOADING HELPER
// ============================================================================

// Load and parse a TOML file
// path: file path string
// Returns: parsed TOML structure, or 0 on error
fn toml_load(path) {
    // Get file size
    let size = file_len(path);
    if size <= 0 { return 0; }

    // Allocate buffer and read file
    let buf = alloc(size + 1);
    let bytes_read = read_file(path, buf, size);

    if bytes_read <= 0 { return 0; }

    // Null-terminate
    poke(buf, bytes_read, 0);

    // Parse and return
    return parse_toml(buf);
}

// ============================================================================
// SECTION 10: DEBUG HELPERS
// ============================================================================

// Print all sections and their keys (for debugging)
fn toml_debug_print(toml) {
    let section_count = toml_mem_read_i64(toml, 0);

    print_str("TOML sections: ");
    print_int(section_count);
    print_str("\n");

    let i = 0;
    while i < section_count {
        let sec_off = TOML_HEADER_SIZE() + i * TOML_SECTION_SIZE();
        let name = toml_mem_read_i64(toml, sec_off);
        let kv_count = toml_mem_read_i64(toml, sec_off + 8);
        let kv_buf = toml_mem_read_i64(toml, sec_off + 16);

        print_str("[");
        print_str(name);
        print_str("] (");
        print_int(kv_count);
        print_str(" keys)\n");

        let j = 0;
        while j < kv_count {
            let kv_off = j * TOML_KV_SIZE();
            let k = toml_mem_read_i64(kv_buf, kv_off);
            let v = toml_mem_read_i64(kv_buf, kv_off + 8);

            print_str("  ");
            print_str(k);
            print_str(" = \"");
            print_str(v);
            print_str("\"\n");

            j = j + 1;
        }

        i = i + 1;
    }

    return 0;
}

// Get the number of sections in a TOML structure
fn toml_section_count(toml) {
    return toml_mem_read_i64(toml, 0);
}

// Get section name by index
fn toml_section_name(toml, index) {
    let section_count = toml_mem_read_i64(toml, 0);
    if index < 0 { return 0; }
    if index >= section_count { return 0; }

    let sec_off = TOML_HEADER_SIZE() + index * TOML_SECTION_SIZE();
    return toml_mem_read_i64(toml, sec_off);
}

// Get key-value count in a section by index
fn toml_kv_count(toml, section_index) {
    let section_count = toml_mem_read_i64(toml, 0);
    if section_index < 0 { return 0; }
    if section_index >= section_count { return 0; }

    let sec_off = TOML_HEADER_SIZE() + section_index * TOML_SECTION_SIZE();
    return toml_mem_read_i64(toml, sec_off + 8);
}
